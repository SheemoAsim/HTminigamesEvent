<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crops Collector 🧑‍🌾</title>
<link href="style.css" rel="stylesheet">
<style>
  /* ✅ Disabled grid style */
  #gameGrid.disabled {
    pointer-events: none;
    opacity: 0.4;
    filter: grayscale(80%);
  }
</style>
</head>
<body style= "background: transparent;">

<div style="display: flex !important; padding: 20px; background: transparent;" class="page" id="page2">

<h1 style="font-size: 1.5em;">Farm Animals Orders 🌾</h1>

<div class="score-info">
  <div>🏆 High score: <span id="highScoreText">0</span></div> |
  <div> Score: <span id="score">0</span></div>
</div>

<div id="gameGrid">
  <div class="emojiBtn" data-id="0"><img src="1/1.png" alt="1"></div>
  <div class="emojiBtn" data-id="1"><img src="1/2.png" alt="2"></div>
  <div class="emojiBtn" data-id="2"><img src="1/3.png" alt="3"></div>
  <div class="emojiBtn" data-id="3"><img src="1/4.png" alt="4"></div>
</div>

  <button id="retry" onclick="resetGame()">🔄</button>
  <div class="retry-left"></div>

</div>
<div class="overlay" id="overlay"></div>

<!-- Tutorial Popup -->
<div style="width:300px;"id="tutorialPopup">
  <h3>Tutorials</h3>
 <p>Welcome to <strong>Farm Animals Orders 🌾</strong>!</p>
  <p>1- Follow the animals’ orders in the correct sequence.</p>
  <p>2- Tap the green light ❇️ → perform the action in order.</p>
  <p>3- Skip the red light 🛑 → if red is last, do nothing for 2 seconds; if it appears in the middle, just continue with green orders.</p>
  <p>Good luck and have fun! 🎉</p>
  
  <button style= "background: #CD923B;" onclick="resetGame()">▶️ Play</button>
</div>

<!-- Game Over Popup -->
<div id="gameOverPopup" class="hidden">
  <h2>Game Over 😢</h2>
  <p>Your Score: <span id="finalScore">0</span></p>
  <p>High Score: <span id="finalHighScore">0</span></p>
  <button onclick="resetGame()">Play Again</button>
  <div style="color: grey !important;" class="retry-left"></div>
</div>


<script>
/* ===== State & config ===== */
let retries = 0;
const maxRetries = 3;

const emojiButtons = Array.from(document.querySelectorAll('.emojiBtn'));
const PLAYER_GRACE_MS = 420;
const TRAILING_RED_WAIT_MS = 2000;

let sequence = [];
let score = 0;
let highScore = Number(localStorage.getItem('simonHighScore') || 0);
let levelSpeed = 600;

let playingBot = false;
let waitingForClick = false;
let trailingWaitActive = false;
let currentStep = 0;
let trailingTimer = null;

/* UI refs */
const highScoreText = document.getElementById('highScoreText');
const scoreEl = document.getElementById('score');
const tutorialPopup = document.getElementById('tutorialPopup');
const gameOverPopup = document.getElementById('gameOverPopup');
const finalScoreEl = document.getElementById('finalScore');
const finalHighScoreEl = document.getElementById('finalHighScore');
const gameGrid = document.getElementById('gameGrid');

highScoreText.textContent = highScore;
scoreEl.textContent = score;

const retryLeftEls = document.getElementsByClassName('retry-left');

function updateRetryLeft() {
  const remaining = Math.max(0, maxRetries - retries);
  Array.from(retryLeftEls).forEach(el => {
    el.textContent = `Retries left: ${remaining}/2`;
  });
}


/* ✅ Disable game when retries are 0 */
function disableGame() {
  gameGrid.classList.add("disabled");
  tutorialPopup.classList.add('hidden');
  document.getElementById('overlay').classList.add('hidden');
}

/* Utility sleep */
const sleep = ms => new Promise(r => setTimeout(r, ms));

/* --- Bot flash visual --- */
function flashBot(step){
  return new Promise(resolve => {
    const btn = emojiButtons[step.id];
    btn.classList.add(step.type === 'green' ? 'greenFlash' : 'redFlash');
    const dur = Math.max(180, Math.floor(levelSpeed * 0.72));
    setTimeout(()=>{
      btn.classList.remove('greenFlash','redFlash');
      resolve();
    }, dur);
  });
}

/* --- Play full sequence --- */
async function playSequence(){
  playingBot = true;
  waitingForClick = false;
  trailingWaitActive = false;
  clearTimeout(trailingTimer);

  for (let i=0;i<sequence.length;i++){
    await flashBot(sequence[i]);
    await sleep(Math.max(120, Math.floor(levelSpeed * 0.44)));
  }

  await sleep(PLAYER_GRACE_MS);
  playingBot = false;

  currentStep = 0;
  while (currentStep < sequence.length && sequence[currentStep].type === 'red') {
    currentStep++;
  }

  if (currentStep >= sequence.length) {
    activateTrailingWait();
  } else {
    waitingForClick = true;
  }
}

function nextRound(){
  const randomId = Math.floor(Math.random()*4);

  const last1 = sequence[sequence.length-1]?.type;
  const last2 = sequence[sequence.length-2]?.type;

  let type;
  if (last1 === 'red' && last2 === 'red') {
    type = 'green';
  } else if (last1 === 'green' && last2 === 'green') {
    type = 'red';
  } else {
    type = Math.random() < 0.7 ? 'green' : 'red';
  }

  sequence.push({ id: randomId, type });

  // Increment score AFTER updating UI
  scoreEl.textContent = score;

  // Update high score correctly
  if (score > highScore) {
    highScore = score;
    highScoreText.textContent = highScore;
    localStorage.setItem('simonHighScore', highScore);
  }

  // Now increment for next round
  score++;

  levelSpeed = Math.max(280, 800 - score * 25);
  playSequence();
}

function activateTrailingWait(){
  trailingWaitActive = true;
  waitingForClick = false;
  clearTimeout(trailingTimer);
  trailingTimer = setTimeout(()=>{
    trailingWaitActive = false;
    nextRound();
  }, TRAILING_RED_WAIT_MS);
}

function handleClick(e){
  const btn = e.currentTarget;
  if (playingBot) return;
  if (trailingWaitActive){
    wrongFlash(btn);
    return endGame();
  }
  if (!waitingForClick) return;

  const id = Number(btn.dataset.id);
  const step = sequence[currentStep];

  if (step && step.type === 'green' && step.id === id){
    correctFlash(btn);
    currentStep++;
    while (currentStep < sequence.length && sequence[currentStep].type === 'red'){
      currentStep++;
    }
    if (currentStep >= sequence.length){
      if (sequence[sequence.length - 1]?.type === 'red'){
        activateTrailingWait();
      } else {
        waitingForClick = false;
        setTimeout(nextRound, 520);
      }
    }
  } else {
    wrongFlash(btn);
    endGame();
  }
}

function correctFlash(btn){
  btn.classList.add('correctClick');
  setTimeout(()=>btn.classList.remove('correctClick'), 180);
}
function wrongFlash(btn){
  btn.classList.add('wrongClick');
  setTimeout(()=>btn.classList.remove('wrongClick'), 220);
}

function startGame(){
  if (retries >= maxRetries) {
    disableGame();
    return;
  }
  tutorialPopup.classList.add('hidden');
  document.getElementById('overlay').classList.add('hidden');
  sequence = [];
  score = 0;
  scoreEl.textContent = score;
  levelSpeed = 800;
  currentStep = 0;
  playingBot = false;
  waitingForClick = false;
  trailingWaitActive = false;
  clearTimeout(trailingTimer);
  nextRound();
}

function endGame(){
  playingBot = false;
  waitingForClick = false;
  trailingWaitActive = false;
  clearTimeout(trailingTimer);

  finalScoreEl.textContent = score;

  // Ensure high score is correct
  highScore = Math.max(highScore, score);
  localStorage.setItem('simonHighScore', highScore);

  finalHighScoreEl.textContent = highScore;
  highScoreText.textContent = highScore;

  gameOverPopup.classList.remove('hidden');
  document.getElementById('overlay').classList.remove('hidden');

  window.parent.postMessage({ 
    type: "highscore", 
    game: 1,
    highscore: highScore 
  }, "*");
}


/* ✅ Reset Game (consumes retry + save to storage) */
function resetGame() {
  if (retries >= maxRetries) {
    alert("No retries left!");
    gameOverPopup.classList.add('hidden');
    document.getElementById('overlay').classList.add('hidden');
    disableGame();
    return;
  }

  gameOverPopup.classList.add('hidden');
document.getElementById('overlay').classList.add('hidden');

  // Start the game
  startGame();

  // Now consume a retry
  retries++;
  localStorage.setItem("farmRetries", retries);
  updateRetryLeft();
}


/* ---------- Preload Images ---------- */
const gameImages=["1/1.png","1/2.png","1/3.png","1/4.png"];
function preloadGameImages(callback){
  let loadedCount=0;
  gameImages.forEach(src=>{
    const img=new Image(); img.src=src;
    if(img.complete) checkDone();
    else img.onload=img.onerror=checkDone;
  });
  function checkDone(){
    loadedCount++;
    if(loadedCount>=gameImages.length){
      console.log("✅ Game 1 images preloaded!");
      window.parent.postMessage("loaded","*");
      callback();
    }
  }
}


/* ✅ Load saved retries on page load */
window.onload=()=>{ 
  document.getElementById("tutorialPopup").style.display="block"; 
  const savedRetries = localStorage.getItem("farmRetries");
  retries = savedRetries ? parseInt(savedRetries) : 0;
  updateRetryLeft();
};

/* --- Bind click events to tiles --- */
emojiButtons.forEach(btn => btn.addEventListener('click', handleClick));

window.startGame = startGame;
window.resetGame = resetGame;


// ✅ Wait until everything is fully loaded (images, CSS, scripts, etc.)
function waitForFullPageLoad(callback) {
  if (document.readyState === "complete") {
    // Already loaded
    callback();
  } else {
    window.addEventListener("load", () => {
      callback();
    });
  }
}

// Example usage
waitForFullPageLoad(() => {
  console.log("✅ All elements fully loaded, now start game logic...");
  // startGame();  // <-- call your game init function here
});
</script>

</body>
</html>
