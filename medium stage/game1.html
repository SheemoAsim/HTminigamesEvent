<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crops Collector 🧑‍🌾</title>
<link href="style.css" rel="stylesheet">
</head>
<body style= "background: transparent;">

<div style="display: flex !important; padding: 20px; background: transparent;" class="page" id="page2">

<h1 style="font-size: 1.5em;">Farm Animals Orders 🌾</h1>

<div class="score-info">
  <div>🏆 High score: <span id="highScoreText">0</span></div> |
  <div> Score: <span id="score">0</span></div>
</div>

<div id="gameGrid">
  <div class="emojiBtn" data-id="0"><img src="1/1.png" alt="1"></div>
  <div class="emojiBtn" data-id="1"><img src="1/2.png" alt="2"></div>
  <div class="emojiBtn" data-id="2"><img src="1/3.png" alt="3"></div>
  <div class="emojiBtn" data-id="3"><img src="1/4.png" alt="4"></div>
</div>

  <button id="retry" onclick="resetGame()">🔄</button>
       <div class="retry-left"></div>

</div>
  <div class="overlay" id="overlay"></div>
</div>

<!-- Tutorial Popup -->
<div style="width:300px;"id="tutorialPopup">
  <h3>Tutorials</h3>
 <p>Welcome to <strong>Farm Animals Orders 🌾</strong>!</p>
  <p>1- Follow the animals’ orders in the correct sequence.</p>
  <p>2- Tap the green light ❇️ → perform the action in order.</p>
  <p>3- Skip the red light 🛑 → if red is last, do nothing for 2 seconds; if it appears in the middle, just continue with green orders.</p>
  <p>Good luck and have fun! 🎉</p>
  
  <button style= "background: #CD923B;" onclick="startGame()">▶️ Play</button>
</div>

<!-- Game Over Popup -->
<div id="gameOverPopup" class="hidden">
  <h2>Game Over 😢</h2>
  <p>Your Score: <span id="finalScore">0</span></p>
  <p>High Score: <span id="finalHighScore">0</span></p>
<button onclick="resetGame()">Play Again</button>
           <div style="color: grey !important;" class="retry-left"></div>

</div>


</div>






<script>
/* ===== State & config ===== */
let retries = 0;
const maxRetries = 3;


const emojiButtons = Array.from(document.querySelectorAll('.emojiBtn'));
const PLAYER_GRACE_MS = 420;      // tiny buffer after bot finishes
const TRAILING_RED_WAIT_MS = 2000; // 2s wait when last is red

let sequence = [];                // array of {id:0..3, type: 'green'|'red'}
let score = 0;
let highScore = Number(localStorage.getItem('simonHighScore') || 0);
let levelSpeed = 600;             // flash speed, will lower as score increases

let playingBot = false;           // true while bot is flashing
let waitingForClick = false;      // true when expecting player green clicks
let trailingWaitActive = false;   // true during last-red 2s no-touch window
let currentStep = 0;              // index of expected next green in sequence
let trailingTimer = null;

/* UI refs */
const highScoreText = document.getElementById('highScoreText');
const scoreEl = document.getElementById('score');
const tutorialPopup = document.getElementById('tutorialPopup');
const gameOverPopup = document.getElementById('gameOverPopup');
const finalScoreEl = document.getElementById('finalScore');
const finalHighScoreEl = document.getElementById('finalHighScore');


highScoreText.textContent = highScore;
scoreEl.textContent = score;

const retryLeftEls = document.getElementsByClassName('retry-left');

function updateRetryLeft() {
  Array.from(retryLeftEls).forEach(el => {
    el.textContent = `Retries left: ${maxRetries-retries}/${maxRetries}`;
  });
}

/* Utility sleep */
const sleep = ms => new Promise(r => setTimeout(r, ms));

/* --- Bot flash visual --- */
function flashBot(step){
  return new Promise(resolve => {
    const btn = emojiButtons[step.id];
    // apply flash class depending on type
    btn.classList.add(step.type === 'green' ? 'greenFlash' : 'redFlash');
    // flash duration proportional to levelSpeed, but bounded
    const dur = Math.max(180, Math.floor(levelSpeed * 0.72));
    setTimeout(()=>{
      btn.classList.remove('greenFlash','redFlash');
      resolve();
    }, dur);
  });
}

/* --- Play full sequence --- */
async function playSequence(){
  playingBot = true;
  waitingForClick = false;
  trailingWaitActive = false;
  clearTimeout(trailingTimer);

  // show each step
  for (let i=0;i<sequence.length;i++){
    await flashBot(sequence[i]);
    await sleep(Math.max(120, Math.floor(levelSpeed * 0.44)));
  }

  // tiny grace after bot finishes to prevent accidental clicks
  await sleep(PLAYER_GRACE_MS);
  playingBot = false;

  // set currentStep to first green index (skip leading reds)
  currentStep = 0;
  while (currentStep < sequence.length && sequence[currentStep].type === 'red') {
    currentStep++;
  }

  // If there are no greens left (sequence entirely red or tail only reds), activate trailing wait
  if (currentStep >= sequence.length) {
    activateTrailingWait();
  } else {
    waitingForClick = true;
  }
}

/* --- Add a new random step and start play --- */
/* We'll use only 'green' and 'red' types, but we prevent more than 2 same colors in a row */
function nextRound(){
  // pick random button id (0..3)
  const randomId = Math.floor(Math.random()*4);

  // determine color type with fairness and prevent long streaks
  const last1 = sequence[sequence.length-1]?.type;
  const last2 = sequence[sequence.length-2]?.type;

  let type;
  if (last1 === 'red' && last2 === 'red') {
    // avoid 3 reds in a row
    type = 'green';
  } else if (last1 === 'green' && last2 === 'green') {
    // avoid 3 greens in a row
    type = 'red';
  } else {
    // fair 50/50 otherwise
    type = Math.random() < 0.7 ? 'green' : 'red';
  }

  sequence.push({ id: randomId, type });

  // update score & speed (score counts rounds)
  scoreEl.textContent = score;
  score++;
  if (score > highScore) {
    highScore = score;
    highScoreText.textContent = highScore;
  }

  // speed up gradually but keep minimum
  levelSpeed = Math.max(280, 800 - score * 25);

  playSequence();
}

/* --- Trailing wait when last step is red --- */
function activateTrailingWait(){
  trailingWaitActive = true;
  waitingForClick = false;
  clearTimeout(trailingTimer);
  trailingTimer = setTimeout(()=>{
    trailingWaitActive = false;
    // move to next round automatically after successful wait
    nextRound();
  }, TRAILING_RED_WAIT_MS);
}

/* --- Player click handler --- */
function handleClick(e){
  const btn = e.currentTarget;

  // Ignore clicks while bot playing
  if (playingBot) return;

  // If trailing wait active and player clicks -> immediate fail
  if (trailingWaitActive){
    wrongFlash(btn);
    return endGame();
  }

  // If not expecting clicks (e.g. sequence had no green yet and no trailing wait), ignore
  if (!waitingForClick) return;

  const id = Number(btn.dataset.id);
  const step = sequence[currentStep];

  // Step must exist and be green and match id
  if (step && step.type === 'green' && step.id === id){
    correctFlash(btn);
    currentStep++;

    // Skip any reds that come next automatically (middle reds)
    while (currentStep < sequence.length && sequence[currentStep].type === 'red'){
      currentStep++;
    }

    // If we've consumed all expected greens for this sequence
    if (currentStep >= sequence.length){
      // If the last overall step in sequence is red → start trailing wait
      if (sequence[sequence.length - 1]?.type === 'red'){
        activateTrailingWait();
      } else {
        // else prepare next round
        waitingForClick = false;
        setTimeout(nextRound, 520);
      }
    } // otherwise still waiting for next green click
  } else {
    // wrong click
    wrongFlash(btn);
    endGame();
  }
}

/* small visual feedback */
function correctFlash(btn){
  btn.classList.add('correctClick');
  setTimeout(()=>btn.classList.remove('correctClick'), 180);
}
function wrongFlash(btn){
  btn.classList.add('wrongClick');
  setTimeout(()=>btn.classList.remove('wrongClick'), 220);
}

/* --- Game lifecycle --- */
function startGame(){
  tutorialPopup.classList.add('hidden');
document.getElementById('overlay').classList.add('hidden');
  sequence = [];
  score = 0;
  scoreEl.textContent = score;
  levelSpeed = 800;
  currentStep = 0;
  playingBot = false;
  waitingForClick = false;
  trailingWaitActive = false;
  clearTimeout(trailingTimer);
  // first round: push two steps to feel like a sequence start (optional)
  nextRound();
}

function endGame(){
  // show Game Over popup and save high score
  document.getElementById('finalScore').textContent = score;
  if (score > Number(localStorage.getItem('simonHighScore') || 0)){
    localStorage.setItem('simonHighScore', score);
  }
  document.getElementById('finalHighScore').textContent = localStorage.getItem('simonHighScore') || 0;
  gameOverPopup.classList.remove('hidden');
document.getElementById('overlay').classList.remove('hidden');

  // reset internal flags
  playingBot = false;
  waitingForClick = false;
  trailingWaitActive = false;
  clearTimeout(trailingTimer);
finalScoreEl.textContent = score;

  if (score > highScore) {
    highScore = score;
    localStorage.setItem("gameHighScore", highScore);
    highScoreEl.textContent = highScore;
  }
  finalHighScoreEl.textContent = highScore;

  // Identify the game (1,2,3)
  window.parent.postMessage({ 
    type: "highscore", 
    game: 1,  // ← change per child (1, 2, 3)
    highscore: highScore 
  }, "*");
}

// ✅ Reset Game (Retry buttons, consumes retry)
function resetGame() {
  if (retries >= maxRetries) {
    alert("No retries left!");
document.getElementById('gameOverPopup').classList.add('hidden');
document.getElementById('overlay').classList.add('hidden');
    return;
  }
  retries++;
  updateRetryLeft();
document.getElementById('gameOverPopup').classList.add('hidden');
  startGame();
}



window.onload=()=>{ 
  document.getElementById("tutorialPopup").style.display="block"; 
    updateRetryLeft();
};


/* --- Bind click events to tiles --- */
emojiButtons.forEach(btn => btn.addEventListener('click', handleClick));

/* expose start/reset on window for popup buttons */
window.startGame = startGame;
window.resetGame = resetGame;
</script>

</body>
</html>
